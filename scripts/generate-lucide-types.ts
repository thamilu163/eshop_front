import * as fs from 'fs';
import * as path from 'path';

// Small, testable parser for lucide-react d.ts content.
export function extractNames(content: string): string[] {
  const names = new Set<string>();

  const exportBlockMatch = content.match(/export\s*\{([\s\S]*?)\};\s*$/m);
  if (exportBlockMatch) {
    const exportList = exportBlockMatch[1];
    const parts = exportList.split(',');
    for (let p of parts) {
      p = p.trim();
      if (!p) continue;
      if (p.includes('createLucideIcon') || p.includes('index as icons') || p.startsWith('type ') || p.includes('LucideProps')) continue;
      const asMatch = p.match(/^([A-Za-z0-9_]+)\s+as\s+([A-Za-z0-9_]+)$/);
      if (asMatch) {
        names.add(asMatch[2]);
      } else {
        const clean = p.replace(/\s+/g, ' ').split(' as ').map(s => s.trim())[0];
        if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(clean)) names.add(clean);
      }
    }
  }

  if (names.size === 0) {
    const regex = /declare const ([A-Za-z0-9_]+):\s*(?:typeof\s+)?([A-Za-z0-9_]+);/g;
    let match: RegExpExecArray | null;
    while ((match = regex.exec(content)) !== null) {
      names.add(match[1]);
    }
  }

  const aliasRegex = /([A-Za-z0-9_]+)\s+as\s+([A-Za-z0-9_]+)/g;
  let aMatch: RegExpExecArray | null;
  while ((aMatch = aliasRegex.exec(content)) !== null) {
    const left = aMatch[1];
    const right = aMatch[2];
    if (left === 'index' || right === 'icons' || left === 'type' || right === 'type') continue;
    if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(left)) names.add(left);
    if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(right)) names.add(right);
  }

  return Array.from(names);
}

export function filterNames(allNames: string[]): string[] {
  const set = new Set(allNames);
  return allNames.filter(n => {
    if (n.endsWith('Icon')) {
      const base = n.slice(0, -4);
      if (set.has(base)) return false;
    }
    return true;
  }).sort();
}

export function generateOutput(filtered: string[]): string {
  const outLines: string[] = [];
  outLines.push('// Generated by scripts/generate-lucide-types.ts — do not edit by hand');
  outLines.push('// Clean declarations for lucide icons using the project-level LucideIcon type');
  outLines.push('');
  outLines.push("import type { LucideIcon } from 'lucide-react';");
  outLines.push('');
  outLines.push('/**');
  outLines.push(' * This file re-exports all named icons from `lucide-react` as typed `LucideIcon` declarations.');
  outLines.push(' * It is safe to regenerate from the upstream `node_modules/lucide-react/dist/lucide-react.d.ts` file.');
  outLines.push(' */');
  outLines.push('');

  for (const name of filtered) {
    const kebab = name.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '');
    outLines.push(`/** @see https://lucide.dev/icons/${kebab} */`);
    outLines.push(`export declare const ${name}: LucideIcon;`);
    outLines.push('');
  }

  outLines.push('export default {} as Record<string, LucideIcon>;');
  return outLines.join('\n');
}

async function main() {
  const distDts = path.join(__dirname, '..', 'node_modules', 'lucide-react', 'dist', 'lucide-react.d.ts');
  const outFile = path.join(__dirname, '..', 'src', 'types', 'lucide-icons.d.ts');

  if (!fs.existsSync(distDts)) {
    console.error('Cannot find lucide-react dist d.ts at', distDts);
    process.exit(1);
  }

  const content = fs.readFileSync(distDts, 'utf8');
  const allNames = extractNames(content);
  const filtered = filterNames(allNames);
  const out = generateOutput(filtered);

  const argv = process.argv.slice(2);
  const checkMode = argv.includes('--check') || argv.includes('-c');
  const generatedCount = filtered.length;
  if (generatedCount === 0) {
    console.error('ERROR: No lucide icons detected — upstream type format may have changed.');
    process.exit(1);
  }

  if (checkMode) {
    if (!fs.existsSync(outFile)) {
      console.error('ERROR: --check: no generated file present at', outFile);
      process.exit(2);
    }
    const existing = fs.readFileSync(outFile, 'utf8');
    if (existing === out) {
      console.log('OK: generated file is up-to-date (', generatedCount, 'icons )');
      process.exit(0);
    } else {
      console.error('ERROR: --check: generated output differs; run `node scripts/generate-lucide-types.ts` to regenerate.');
      process.exit(3);
    }
  }

  fs.mkdirSync(path.dirname(outFile), { recursive: true });
  fs.writeFileSync(outFile, out, 'utf8');
  console.log('Wrote', outFile, 'with', generatedCount, 'icons');
}

declare const require: any;
if (typeof require !== 'undefined' && require.main && typeof require.main.filename === 'string' && (require.main.filename.endsWith('generate-lucide-types.ts') || require.main.filename.endsWith('generate-lucide-types.js'))) {
  main().catch(e => {
    const msg = e instanceof Error ? e.message : String(e);
    console.error('Fatal:', msg);
    process.exit(1);
  });
}

export default { extractNames, filterNames, generateOutput };
